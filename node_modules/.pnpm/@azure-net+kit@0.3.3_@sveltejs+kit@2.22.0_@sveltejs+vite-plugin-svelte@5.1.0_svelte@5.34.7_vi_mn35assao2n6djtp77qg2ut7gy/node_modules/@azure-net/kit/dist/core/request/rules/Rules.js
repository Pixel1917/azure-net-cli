import { isValidNumber } from 'libphonenumber-js';
export class Rules {
    validationMessages;
    constructor(validationMessages) {
        this.validationMessages = validationMessages;
    }
    checkVal(val) {
        return val !== undefined && val !== null;
    }
    string(params) {
        const { message, length } = { ...params, message: { ...this.validationMessages.string, ...params?.message } };
        return ({ val }) => {
            if (this.checkVal(val)) {
                if (typeof val !== 'string') {
                    return message.base();
                }
                switch (true) {
                    case length && this.checkVal(length.min) && val.length < length.min:
                        return message.min(length.min);
                    case length && this.checkVal(length.max) && val.length > length.max:
                        return message.max(length.max);
                    default:
                        return undefined;
                }
            }
            return undefined;
        };
    }
    number(params) {
        const { message, range } = { ...params, message: { ...this.validationMessages.number, ...params?.message } };
        return ({ val }) => {
            if (this.checkVal(val)) {
                const numberVal = Number(val);
                if (!Number.isInteger(numberVal) || Number.isNaN(numberVal)) {
                    return message.base();
                }
                switch (true) {
                    case range && this.checkVal(range?.min) && numberVal < range.min:
                        return message.min(range.min);
                    case range && this.checkVal(range?.max) && numberVal > range.max:
                        return message.max(range.max);
                    default:
                        return undefined;
                }
            }
            return undefined;
        };
    }
    finite(params) {
        const { message, maxDigitsAfterDot, range } = { ...params, message: { ...this.validationMessages.finite, ...params?.message } };
        return ({ val }) => {
            if (this.checkVal(val)) {
                const numVal = Number(val);
                if (!Number.isFinite(numVal) || String(val)[0] === '.') {
                    return message.base();
                }
                if (typeof maxDigitsAfterDot === 'number') {
                    const digitsAfterDot = val.toString().split('.')[1]?.length ?? 0;
                    if (digitsAfterDot > maxDigitsAfterDot) {
                        return message.maxDigitsAfterDot(maxDigitsAfterDot);
                    }
                }
                if (range?.min !== undefined && numVal < range.min)
                    return message.min(range.min);
                if (range?.max !== undefined && numVal > range.max)
                    return message.max(range.max);
                return undefined;
            }
            return undefined;
        };
    }
    boolean(params) {
        const { message, expected } = { ...params, message: { ...this.validationMessages.boolean, ...params?.message } };
        return ({ val }) => {
            if (this.checkVal(val)) {
                if (typeof val !== 'boolean')
                    return message.base();
                if (expected !== undefined && val !== expected)
                    return message.expected(String(expected));
                return undefined;
            }
            return undefined;
        };
    }
    array(params) {
        const { message, length = {}, schema } = { ...params, message: { ...this.validationMessages.array, ...params?.message } };
        return ({ val, listValues, key }) => {
            if (this.checkVal(val)) {
                if (!Array.isArray(val))
                    return message.base();
                if (length.min && val.length < length.min)
                    return message.min(length.min);
                if (length.max && val.length > length.max)
                    return message.max(length.max);
                if (schema) {
                    const nestedErrors = [];
                    for (let index = 0; index < val.length; index++) {
                        const element = val[index];
                        const itemErrors = {};
                        if (Array.isArray(schema)) {
                            for (const rule of schema) {
                                const fail = rule({
                                    val: element,
                                    listValues,
                                    key: `${key}[${index}]`
                                });
                                if (fail) {
                                    itemErrors['_error'] = fail;
                                    break;
                                }
                            }
                        }
                        else if (typeof schema === 'object' && schema !== null) {
                            if (typeof element !== 'object' || element === null) {
                                itemErrors['_error'] = message.base();
                            }
                            else {
                                for (const fieldKey in schema) {
                                    const fieldRules = schema[fieldKey] ?? [];
                                    const fieldValue = element?.[fieldKey];
                                    for (const rule of fieldRules) {
                                        const fail = rule({
                                            val: fieldValue,
                                            listValues,
                                            key: `${key}[${index}].${fieldKey}`
                                        });
                                        if (fail) {
                                            itemErrors[fieldKey] = fail;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        nestedErrors[index] = itemErrors;
                    }
                    if (nestedErrors.some((e) => Object.keys(e).length > 0)) {
                        return nestedErrors;
                    }
                }
            }
            return undefined;
        };
    }
    phone(params) {
        const { message, country = 'RU' } = { ...params, message: params?.message ?? this.validationMessages.phone };
        return ({ val }) => {
            if (this.checkVal(val)) {
                return isValidNumber(String(val), country) ? undefined : message();
            }
            return undefined;
        };
    }
    email(params) {
        const { message } = { message: params?.message ?? this.validationMessages.email };
        const emailRegExp = 
        // eslint-disable-next-line no-control-regex
        /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0B\x0C\x0E-\x1F\x21\x23-\x5B\x5D-\x7F]|[\x01-\x09\x0B\x0C\x0E-\x7F])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0B\x0C\x0E-\x1F\x21-\x5A\x53-\x7F]|\\[\x01-\x09\x0B\x0C\x0E-\x7F])+)])$/i;
        return ({ val }) => {
            if (this.checkVal(val)) {
                const stringedVal = typeof val === 'string' ? String(val) : undefined;
                return stringedVal && emailRegExp.test(stringedVal) ? undefined : message();
            }
            return undefined;
        };
    }
    lettersOnly(params) {
        const { message, whiteSpaces = false } = { ...params, message: params?.message ?? this.validationMessages.lettersOnly };
        const lettersRegex = whiteSpaces ? /^[а-яА-Яa-zA-Z\s]+$/ : /^[а-яА-Яa-zA-Z]+$/;
        return ({ val }) => {
            if (this.checkVal(val)) {
                const stringedVal = typeof val === 'string' ? String(val) : undefined;
                return stringedVal && lettersRegex.test(stringedVal) ? undefined : message(whiteSpaces);
            }
            return undefined;
        };
    }
    allowedOnly(params) {
        const { message, allowed } = { ...params, message: params?.message ?? this.validationMessages.allowedOnly };
        return ({ val }) => {
            if (this.checkVal(val)) {
                switch (true) {
                    case !!allowed && Array.isArray(allowed):
                        if (!allowed?.length) {
                            return message('');
                        }
                        return allowed.includes(val) ? undefined : message(allowed.join(', '));
                    default:
                        return undefined;
                }
            }
            return undefined;
        };
    }
    sameAs(params) {
        const { message, key } = { ...params, message: params?.message ?? this.validationMessages.sameAs };
        return ({ val, listValues }) => {
            if (this.checkVal(val)) {
                switch (true) {
                    case typeof val === 'object':
                        if (!listValues?.[key] || typeof listValues[key] !== 'object') {
                            return message(String(key));
                        }
                        try {
                            return JSON.stringify(val) === JSON.stringify(listValues[key]) ? undefined : message(String(key));
                        }
                        catch {
                            return undefined;
                        }
                    default:
                        return String(val ?? '') === String(listValues?.[key] ?? '') ? undefined : message(String(key));
                }
            }
            return undefined;
        };
    }
    notSameAs(params) {
        const { message, key } = { ...params, message: params?.message ?? this.validationMessages.notSameAs };
        return ({ val, listValues }) => {
            if (this.checkVal(val)) {
                switch (true) {
                    case typeof val === 'object':
                        if (!listValues?.[key] || typeof listValues[key] !== 'object') {
                            return message(String(key));
                        }
                        try {
                            return JSON.stringify(val) !== JSON.stringify(listValues[key]) ? undefined : message(String(key));
                        }
                        catch {
                            return undefined;
                        }
                    default:
                        return String(val) === String(listValues?.[key]) ? undefined : message(String(key));
                }
            }
            return undefined;
        };
    }
    required(params) {
        const { message, byCondition } = { ...params, message: params?.message ?? this.validationMessages.required };
        return ({ val, listValues, key }) => {
            if (!this.checkVal(val))
                return message();
            if (byCondition && !byCondition({ val, listValues, key }))
                return undefined;
            if (typeof val === 'string' && !val.length)
                return message();
            if (val instanceof File && val.size < 1)
                return message();
            if (typeof val === 'number' && !String(val).length)
                return message();
            return undefined;
        };
    }
    password(params) {
        const { message, length = 8, specialChars, numbers, lowerUpperCasePattern } = { ...params, message: { ...this.validationMessages.password, ...params?.message } };
        return ({ val }) => {
            if (!this.checkVal(val))
                return undefined;
            const str = String(val);
            if (str.length < length) {
                return message.length(length);
            }
            if (specialChars) {
                const minCount = typeof specialChars === 'number' ? specialChars : 1;
                const count = (str.match(/[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?]/g) || []).length;
                if (count < minCount) {
                    return message.specialChars(minCount);
                }
            }
            if (numbers) {
                const minCount = typeof numbers === 'number' ? numbers : 1;
                const count = (str.match(/[0-9]/g) || []).length;
                if (count < minCount) {
                    return message.numbers(minCount);
                }
            }
            if (lowerUpperCasePattern) {
                const hasLower = /[a-z]/.test(str);
                const hasUpper = /[A-Z]/.test(str);
                if (!hasLower || !hasUpper) {
                    return message.lowerUpperCasePattern();
                }
            }
            return undefined;
        };
    }
}
