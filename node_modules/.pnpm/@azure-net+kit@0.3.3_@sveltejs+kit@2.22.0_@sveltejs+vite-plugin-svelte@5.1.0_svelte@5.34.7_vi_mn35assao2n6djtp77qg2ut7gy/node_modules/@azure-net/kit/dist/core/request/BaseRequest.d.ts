type DeepKeys<T> = T extends object ? {
    [K in keyof T & string]: T[K] extends object ? K | `${K}.${DeepKeys<T[K]>}` : K;
}[keyof T & string] : never;
export type ValidationParams<T = unknown, V = unknown, K = string> = {
    val: V;
    listValues?: Partial<T>;
    key?: K;
};
export type ValidationMessage = string | {
    key: string;
    vars?: Record<string, unknown>;
};
export interface ValidationErrorsMap {
    [key: string]: ValidationMessage | ValidationErrorsMap;
}
export type ValidationResult = ValidationMessage | ValidationErrorsMap | ValidationErrorsMap[] | undefined;
export type ValidationRuleResult<CurrentValue, ListValues = unknown, CurrentKey = string> = (params: ValidationParams<CurrentValue, ListValues, CurrentKey>) => ValidationResult;
type ValidationErrors<T> = T extends ReadonlyArray<infer U> ? ValidationErrors<U>[] : T extends object ? {
    [K in keyof T]?: ValidationErrors<T[K]>;
} : ValidationMessage;
export type RequestErrors<Dict> = Partial<ValidationErrors<Dict>>;
export type RequestRules<D> = Partial<Record<DeepKeys<D>, ValidationRuleResult<D>[]>>;
export interface IRequest<T, D = T> {
    rules?(): RequestRules<D>;
}
export declare class BaseRequest<T, D = T> implements IRequest<T, D> {
    data: D;
    errors: RequestErrors<D>;
    isValid: boolean;
    constructor(data: Partial<D> | FormData);
    rules(): RequestRules<D>;
    private prepareData;
    transform(data: D): T;
    formData(): FormData;
    json(): T;
    getErrors(): Partial<ValidationErrors<D>>;
    private getByPath;
    private setByPath;
    validated(): this;
}
export {};
